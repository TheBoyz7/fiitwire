<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SportWire | League Overview</title>
  <link rel="stylesheet" href="css/styles.css">
  <link rel="stylesheet" href="css/leaguesss.css">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    [data-tap].active { transform: scale(0.98); }
    @media (max-width: 768px) {
      .fixture-item { padding: 10px !important; gap: 8px !important; }
      .fixture-item img { width: 24px !important; height: 24px !important; margin: 0 8px !important; }
      .fixture-item span { font-size: 13px !important; }
      .fixture-item a { font-size: 12px !important; }
      .fixture-item a.view-match { flex-basis: 100%; text-align: center; }
    }
    @media (max-width: 480px) {
      .fixture-item { padding: 8px !important; gap: 6px !important; }
      .fixture-item img { width: 20px !important; height: 20px !important; margin: 0 6px !important; }
      .fixture-item span { font-size: 12px !important; }
      .fixture-item a { font-size: 11px !important; }
    }
  </style>
</head>
<body>
  <!-- Site Header -->
  <header class="site-header">
    <div class="container">
      <h1>SportsWire ⚽ <span id="league-name">Loading...</span></h1>
      <nav class="main-nav">
        <ul>
          <li><a href="index.php">Home</a></li>
          <li><a href="news.php">News</a></li>
          <li><a href="league.html">Leagues</a></li>
          <li><a href="team.html">Teams</a></li>
          <li><a href="live.html">Live Scores</a></li>
        </ul>
      </nav>
    </div>
  </header>

  <!-- League Banner -->
  <section class="league-banner">
    <div class="container">
      <img src="https://cdn.sportmonks.com/images/soccer/placeholder.png" alt="League Logo" class="league-logo" id="league-logo">
      <div class="league-info">
        <h2 id="league-title">Loading...</h2>
        <p class="league-description" id="league-description">Loading league description...</p>
      </div>
    </div>
  </section>

  <!-- Primary Tabs -->
  <nav class="league-tabs container" role="tablist">
    <button class="tab-btn active" data-tab="overview" role="tab" aria-selected="true" aria-controls="overview">Overview</button>
    <button class="tab-btn" data-tab="standings" role="tab" aria-selected="false" aria-controls="standings">Standings</button>
    <button class="tab-btn" data-tab="fixtures" role="tab" aria-selected="false" aria-controls="fixtures">Fixtures</button>
    <button class="tab-btn" data-tab="statistics" role="tab" aria-selected="false" aria-controls="statistics">Statistics</button>
  </nav>

  <!-- Tab Contents -->
  <main class="league-content container">
    <!-- Overview -->
    <section id="overview" class="tab-content active" role="tabpanel">
      <div class="overview-widgets">
        <div class="overview-video">
          <h4>Weekly League News</h4>
          <div class="video-container">
            <p>Video content coming soon</p>
          </div>
        </div>
        <div class="overview-fixtures">
          <h4>Upcoming Fixtures</h4>
          <ul class="fixtures" id="fixtures-preview"></ul>
        </div>
      </div>
      <div class="league-overview">
        <div class="overview-team-of-week">
          <h4>Team of the Week</h4>
          <div class="pitch-container">
            <p>Team of the Week coming soon</p>
          </div>
        </div>
        <div class="league-table-container" id="league-table-container"></div>
      </div>
    </section>

    <!-- Standings -->
    <section id="standings" class="tab-content" role="tabpanel">
      <h3>Current Standings</h3>
      <div id="error" class="error"></div>
      <div class="standings-container">
        <table class="standings-table">
         
          <tbody id="standings-body"></tbody>
        </table>
      </div>
    </section>

    <!-- Fixtures -->
    <section id="fixtures" class="tab-content" role="tabpanel">
      <h3>Fixtures</h3>
      <div id="fixtures-list">
        <p id="no-fixtures" style="display:none; color:#facc15;">No fixtures found for this league.</p>
      </div>
    </section>

    <!-- Statistics -->
    <section id="statistics" class="tab-content" role="tabpanel">
      <h3>Statistics</h3>
      <div id="stats-sections">
        <section>
          <h2>Top Scorers</h2>
          <ul id="top-goals"></ul>
        </section>
        <section>
          <h2>Top Assists</h2>
          <ul id="top-assists"></ul>
        </section>
        <section>
          <h2>Red Cards</h2>
          <ul id="top-reds"></ul>
        </section>
        <section>
          <h2>Yellow Cards</h2>
          <ul id="top-yellows"></ul>
        </section>
        <section>
          <h2>Most Goals (Team)</h2>
          <ul id="team-goals"></ul>
        </section>
        <section>
          <h2>Most Clean Sheets (Team)</h2>
          <ul id="team-cleansheets"></ul>
        </section>
      </div>
    </section>
  </main>

  <!-- Footer -->
  <footer class="site-footer">
    <div class="container">
      <p>&copy; 2025 SportsWire. All rights reserved.</p>
      <ul class="footer-links">
        <li><a href="#" aria-label="Privacy Policy">Privacy</a></li>
        <li><a href="#" aria-label="Terms of Service">Terms</a></li>
        <li><a href="#" aria-label="Contact Us">Contact</a></li>
      </ul>
      <ul class="social-icons">
        <li><a href="#" aria-label="Twitter/X"><img src="icons/x.svg" alt=""></a></li>
        <li><a href="#" aria-label="Instagram"><img src="icons/instagram.svg" alt=""></a></li>
        <li><a href="#" aria-label="YouTube"><img src="icons/youtube.svg" alt=""></a></li>
      </ul>
    </div>
  </footer>

  <script>

// Configuration
const API_BASE_URL = window.FOOTWIRE_API_BASE_URL || 'http://localhost:3000/api';
const FALLBACK_LOGO = 'https://cdn.sportmonks.com/images/soccer/placeholder.png';
const FALLBACK_TEXT = 'N/A';
const DEFAULT_SEASON_ID = '25583'; // Fallback season ID

// Utility to sanitize text to prevent XSS
function sanitizeText(text) {
  const div = document.createElement('div');
  div.textContent = text || FALLBACK_TEXT;
  return div.innerHTML;
}

// Utility to create an image element with fallback
function createImage(src, alt, className) {
  const img = document.createElement('img');
  img.src = src || FALLBACK_LOGO;
  img.alt = alt || FALLBACK_TEXT;
  if (className) img.className = className;
  img.onerror = () => { img.src = FALLBACK_LOGO; };
  return img;
}

// Fetch league data and season ID
async function fetchLeagueData(leagueId) {
  try {
    const response = await fetch(`${API_BASE_URL}/leagues?filters=leagueIds:${leagueId}&include=seasons`);
    if (!response.ok) throw new Error(`HTTP ${response.status}: Failed to fetch league data`);
    const data = await response.json();
    console.log('League API Response:', data); // Debug
    if (!data?.length) throw new Error('League not found');
    const league = data[0];
    return {
      id: league.id,
      name: league.name || FALLBACK_TEXT,
      logo: league.image_path || FALLBACK_LOGO,
      description: league.description || 'Top-flight football competition.',
      seasonId: league.seasons?.find(s => s.is_current)?.id || DEFAULT_SEASON_ID,
      seasonStart: league.seasons?.find(s => s.is_current)?.starting_at || '2024-08-01',
      seasonEnd: league.seasons?.find(s => s.is_current)?.ending_at || '2026-12-31'
    };
  } catch (err) {
    console.error('Error fetching league data:', err);
    document.getElementById('error').textContent = `Failed to load league data: ${err.message}`;
    return null;
  }
}

// Fetch standings using seasonId
let standingsCache = null;
async function fetchStandings(seasonId) {
  if (standingsCache) return standingsCache;
  try {
    const response = await fetch(`${API_BASE_URL}/standings/${seasonId}`);
    if (!response.ok) throw new Error(`HTTP ${response.status}: Failed to fetch standings`);
    const data = await response.json();
    console.log('Standings API Response:', data); // Debug
    standingsCache = (data.data || []).map(item => ({
      id: item.participant?.id || 0,
      name: item.participant?.name || FALLBACK_TEXT,
      image_path: item.participant?.image_path || FALLBACK_LOGO,
      position: item.position || 0,
      played: item.played || 0,
      won: item.won || 0,
      drawn: item.drawn || 0,
      lost: item.lost || 0,
      goals_scored: item.goals_for || 0,
      goals_conceded: item.goals_against || 0,
      points: item.points || 0
    }));
    if (!standingsCache.length) throw new Error('No standings data available for this season');
    return standingsCache;
  } catch (err) {
    console.error('Error fetching standings:', err);
    document.getElementById('error').textContent = `Failed to load standings: ${err.message}. The season may not have started yet.`;
    return [];
  }
}

// Fetch fixtures with pagination support
async function fetchFixtures(leagueId, startDate, endDate) {
  try {
    let formattedStartDate = new Date(startDate).toISOString().split('T')[0] || new Date().toISOString().split('T')[0];
    let formattedEndDate = new Date(endDate).toISOString().split('T')[0] || formattedStartDate;
    let allFixtures = [];
    const seenFixtures = new Set(); // Track unique fixtures
    let page = 1;
    let totalPages = 1;

    do {
      const url = `${API_BASE_URL}/fixtures?filters=leagueIds:${leagueId}&startDate=${formattedStartDate}&endDate=${formattedEndDate}&include=participants;league;scores&page=${page}`;
      console.log(`Fixtures API URL (page ${page}/${totalPages}):`, url); // Debug
      await new Promise(resolve => setTimeout(resolve, 100)); // Delay to respect rate limits
      const response = await fetch(url);
      if (!response.ok) throw new Error(`HTTP ${response.status}: Failed to fetch fixtures`);
      const responseData = await response.json();
      console.log(`Fixtures API Response (page ${page}):`, responseData); // Debug
      const fixtures = Array.isArray(responseData.data) ? responseData.data : Array.isArray(responseData) ? responseData : [];
      const filteredFixtures = fixtures.filter(f => String(f.league_id) === String(leagueId));

      filteredFixtures.forEach(fixture => {
        const uniqueKey = fixture.id ? fixture.id.toString() : 
          `${fixture.participants?.find(p => p.meta?.location === 'home')?.id || '0'}_${fixture.participants?.find(p => p.meta?.location === 'away')?.id || '0'}_${new Date(fixture.starting_at).toISOString()}`;
        if (!seenFixtures.has(uniqueKey)) {
          seenFixtures.add(uniqueKey);
          allFixtures.push(fixture);
        } else {
          console.warn(`Duplicate fixture detected: ${uniqueKey}`); // Debug
        }
      });

      if (responseData.meta?.pagination) {
        totalPages = responseData.meta.pagination.total_pages || 1;
        page++;
      } else {
        page = totalPages + 1;
      }
    } while (page <= totalPages);

    console.log(`Fixtures fetched for ${formattedStartDate} to ${formattedEndDate}: ${allFixtures.length} items`); // Debug
    return allFixtures;
  } catch (err) {
    console.error('Error fetching fixtures:', err);
    document.getElementById('error').textContent = `Failed to load fixtures: ${err.message}`;
    return [];
  }
}

// Fetch statistics
async function fetchStat(endpoint, seasonId) {
  try {
    const res = await fetch(`${API_BASE_URL}${endpoint}/${seasonId}`);
    if (!res.ok) throw new Error(`HTTP ${res.status}: Failed to fetch ${endpoint}`);
    const text = await res.text();
    const data = text ? JSON.parse(text) : {};
    console.log(`Stat API Response (${endpoint}):`, data); // Debug
    return Array.isArray(data) ? data : data.data || [];
  } catch (err) {
    console.error(`Error fetching ${endpoint}:`, err);
    document.getElementById('error').textContent = `Failed to load statistics: ${err.message}`;
    return [];
  }
}

// Render standings table
function renderStandings(standings, containerId, limit = null) {
  const container = document.getElementById(containerId);
  if (!container) return;
  container.innerHTML = '';
  if (!standings?.length) {
    container.textContent = 'No standings data available for this season. The season may not have started yet.';
    return;
  }
  const table = document.createElement('table');
  table.className = 'standings-table';
  const thead = document.createElement('thead');
  thead.innerHTML = `
    <tr>
      <th scope="col">Pos</th>
      <th scope="col">Club</th>
      <th scope="col">MP</th>
      <th scope="col">W</th>
      <th scope="col">D</th>
      <th scope="col">L</th>
      <th scope="col">GF</th>
      <th scope="col">GA</th>
      <th scope="col">GD</th>
      <th scope="col">Pts</th>
    </tr>
  `;
  const tbody = document.createElement('tbody');
  const standingsToShow = limit ? standings.slice(0, limit) : standings;
  standingsToShow.forEach(team => {
    const goalDifference = team.goals_scored - team.goals_conceded;
    const row = document.createElement('tr');
    row.appendChild(document.createElement('td')).textContent = team.position || '-';
    const teamCell = document.createElement('td');
    teamCell.appendChild(createImage(team.image_path, `${team.name} logo`, 'club-logo-small'));
    const teamLink = document.createElement('a');
    teamLink.href = `club.html?id=${team.id}`;
    teamLink.textContent = team.name;
    teamCell.appendChild(teamLink);
    row.appendChild(teamCell);
    row.appendChild(document.createElement('td')).textContent = team.played || '0';
    row.appendChild(document.createElement('td')).textContent = team.won || '0';
    row.appendChild(document.createElement('td')).textContent = team.drawn || '0';
    row.appendChild(document.createElement('td')).textContent = team.lost || '0';
    row.appendChild(document.createElement('td')).textContent = team.goals_scored || '0';
    row.appendChild(document.createElement('td')).textContent = team.goals_conceded || '0';
    row.appendChild(document.createElement('td')).textContent = goalDifference || '0';
    row.appendChild(document.createElement('td')).textContent = team.points || '0';
    tbody.appendChild(row);
  });
  table.appendChild(thead);
  table.appendChild(tbody);
  container.appendChild(table);
}

// Render fixtures for overview tab
function renderOverviewFixtures(fixtures, containerId) {
  const container = document.getElementById(containerId);
  const noFixturesMsg = document.getElementById('no-fixtures');
  if (!container) {
    console.error('Container not found:', containerId);
    return;
  }
  container.innerHTML = '';
  if (noFixturesMsg) noFixturesMsg.style.display = 'none';

  const now = new Date('2025-08-12T13:54:00+01:00'); // Updated to 01:54 PM WAT
  const upcomingFixtures = fixtures
    .filter(f => {
      const startTime = new Date(f.starting_at);
      if (isNaN(startTime.getTime())) {
        console.warn('Invalid starting_at for fixture:', f);
        return false;
      }
      return startTime > now;
    })
    .sort((a, b) => {
      const timeA = a.starting_at_timestamp || new Date(a.starting_at).getTime();
      const timeB = b.starting_at_timestamp || new Date(b.starting_at).getTime();
      return timeA - timeB;
    })
    .slice(0, 5); // Limit to 5 matches

  console.log('Upcoming fixtures to render (overview):', upcomingFixtures); // Debug

  if (!upcomingFixtures.length) {
    console.warn('No upcoming fixtures found for rendering.');
    if (noFixturesMsg) {
      noFixturesMsg.textContent = 'No upcoming matches found.';
      noFixturesMsg.style.display = 'block';
    }
    return;
  }

  upcomingFixtures.forEach(f => {
    const home = f.participants?.find(p => p.meta?.location === 'home') || {};
    const away = f.participants?.find(p => p.meta?.location === 'away') || {};
    const time = new Date(f.starting_at).toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
    const date = new Date(f.starting_at).toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric' });
    const li = document.createElement('li');
    li.className = 'fixture-item';
    li.innerHTML = `
      <img src="${home.image_path || FALLBACK_LOGO}" alt="${sanitizeText(home.name)} Logo" class="fixture-logo home-logo">
      <span class="fixture-date">${date}</span>
      <span class="fixture-match">${sanitizeText(home.name)} vs ${sanitizeText(away.name)} — ${time}</span>
      <img src="${away.image_path || FALLBACK_LOGO}" alt="${sanitizeText(away.name)} Logo" class="fixture-logo away-logo">
    `;
    container.appendChild(li);
  });
}

// Render fixtures for fixtures tab
function renderFixtures(fixtures, containerId, append = false, prepend = false, showLoadPreviousButton = false, showScrollMessage = false) {
  const container = document.getElementById(containerId);
  const noFixturesMsg = document.getElementById('no-fixtures');
  if (!container) return;

  if (!append && !prepend) {
    container.innerHTML = '';
    if (noFixturesMsg) noFixturesMsg.style.display = 'none';
    if (showLoadPreviousButton) {
      container.insertAdjacentHTML('afterbegin', `
        <button id="load-previous-matches" class="load-previous-btn" style="position: sticky; top: 0; background: #1a202c; padding: 10px; z-index: 10; width: 100%; border: 1px solid #facc15; border-radius: 8px; color: #facc15; font-size: 14px; cursor: pointer;">
          Load Previous Fixtures
        </button>
      `);
    }
  }
  if (!fixtures?.length && !append && !prepend) {
    if (noFixturesMsg) {
      noFixturesMsg.textContent = 'No matches found for this period.';
      noFixturesMsg.style.display = 'block';
    }
    return;
  }

  if (prepend) {
    fixtures = [...fixtures].reverse(); // Reverse to prepend in correct order (most recent at top)
  }

  fixtures.forEach(fixture => {
    const home = fixture.participants?.find(p => p.meta?.location === 'home') || {};
    const away = fixture.participants?.find(p => p.meta?.location === 'away') || {};
    const now = new Date('2025-08-12T13:54:00+01:00'); // Updated to 01:54 PM WAT
    const matchTime = new Date(fixture.starting_at);
    const minutesSinceStart = (now - matchTime) / 1000 / 60;
    let matchStatus = '';
    let scoreDisplay = '';
    if (matchTime > now) {
      matchStatus = matchTime.toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric' });
    } else if (minutesSinceStart >= 0 && minutesSinceStart < 45) {
      matchStatus = `${Math.floor(minutesSinceStart)}'`;
    } else if (minutesSinceStart >= 45 && minutesSinceStart < 60) {
      matchStatus = 'HT';
    } else if (minutesSinceStart >= 60 && minutesSinceStart < 90 + 15) {
      matchStatus = `${Math.floor(minutesSinceStart)}'`;
    } else {
      matchStatus = 'FT';
    }
    if (fixture.scores?.length >= 2 && (minutesSinceStart >= 0 || fixture.result_info)) {
      const homeScore = fixture.scores.find(s => s.description === 'CURRENT' && s.score?.participant === 'home')?.score?.goals || 0;
      const awayScore = fixture.scores.find(s => s.description === 'CURRENT' && s.score?.participant === 'away')?.score?.goals || 0;
      scoreDisplay = `${homeScore} - ${awayScore}`;
    } else {
      scoreDisplay = '-';
    }
    const time = new Date(fixture.starting_at).toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
    const date = new Date(fixture.starting_at).toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric' });
    const html = `
      <div class="fixture-item ${matchTime > now ? 'upcoming-match' : minutesSinceStart >= 0 && minutesSinceStart < 105 ? 'live-match' : 'past-match'}" data-tap style="display: flex; flex-wrap: wrap; align-items: center; justify-content: space-between; padding: 12px; margin: 8px 0; border: 1px solid #facc15; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.2); gap: 8px; transition: transform 0.2s;">
        <img src="${home.image_path || FALLBACK_LOGO}" alt="${sanitizeText(home.name)} Logo" style="width: 28px; height: 28px; margin: 0 8px; border: 1px solid #facc15; border-radius: 50%; vertical-align: middle; transition: transform 0.2s;">
        <span style="font-size: 14px; font-weight: 500; color: #fff; margin: 0 8px;">${date} ${time} (${matchStatus})</span>
        <span style="font-size: 14px; font-weight: 500; color: #fff; margin: 0 8px; text-align: center; flex-grow: 1;">
          <a href="club.html?id=${home.id || ''}" style="color: #facc15; text-decoration: none;">${sanitizeText(home.name)}</a> ${scoreDisplay} <a href="club.html?id=${away.id || ''}" style="color: #facc15; text-decoration: none;">${sanitizeText(away.name)}</a>
        </span>
        <img src="${away.image_path || FALLBACK_LOGO}" alt="${sanitizeText(away.name)} Logo" style="width: 28px; height: 28px; margin: 0 8px; border: 1px solid #facc15; border-radius: 50%; vertical-align: middle; transition: transform 0.2s;">
        <a href="match.html?id=${fixture.id}" class="view-match" style="font-size: 12px; color: #facc15; text-decoration: none; margin: 0 8px;">View Match</a>
      </div>
    `;
    container.insertAdjacentHTML(prepend ? 'afterbegin' : 'beforeend', html);
  });

  if (showScrollMessage) {
    const existingScrollMessage = container.querySelector('.scroll-message');
    if (existingScrollMessage) existingScrollMessage.remove();
    container.insertAdjacentHTML('beforeend', `
      <p class="scroll-message" style="text-align: center; color: #facc15; font-size: 14px; margin: 10px 0; position: sticky; bottom: 0; background: #1a202c; padding: 10px; z-index: 10;">
        Scroll to load more
      </p>
    `);
  }

  const fixtureItems = container.querySelectorAll('[data-tap]');
  fixtureItems.forEach(item => {
    item.addEventListener('touchstart', () => item.classList.add('active'));
    item.addEventListener('touchend', () => item.classList.remove('active'));
    item.addEventListener('touchcancel', () => item.classList.remove('active'));
  });
}

// Render player statistics
function renderPlayerList(selector, players, valueLabel) {
  const list = document.querySelector(selector);
  if (!list) return;
  list.innerHTML = '';
  if (!players?.length) {
    list.textContent = `No ${valueLabel} data available.`;
    return;
  }
  players.slice(0, 5).forEach(player => {
    const li = document.createElement('li');
    li.appendChild(createImage(player.player?.image_path, player.player?.display_name));
    const playerLink = document.createElement('a');
    playerLink.href = `player.html?id=${player.player?.id}`;
    playerLink.textContent = player.player?.display_name || FALLBACK_TEXT;
    li.appendChild(playerLink);
    li.appendChild(document.createElement('small')).textContent = `(${sanitizeText(player.participant?.name)})`;
    li.appendChild(createImage(player.participant?.image_path, player.participant?.name, 'club-logo-small'));
    const span = document.createElement('span');
    span.innerHTML = `<strong>${player.total || 0}</strong> ${valueLabel}`;
    li.appendChild(span);
    list.appendChild(li);
  });
}

// Render team statistics
function renderTeamList(selector, teams, valueLabel) {
  const list = document.querySelector(selector);
  if (!list) return;
  list.innerHTML = '';
  if (!teams?.length) {
    list.textContent = `No ${valueLabel} data available.`;
    return;
  }
  teams.slice(0, 5).forEach(team => {
    const li = document.createElement('li');
    li.appendChild(createImage(team.image, team.name));
    const teamLink = document.createElement('a');
    teamLink.href = `club.html?id=${team.id}`;
    teamLink.textContent = team.name;
    li.appendChild(teamLink);
    const span = document.createElement('span');
    span.innerHTML = `<strong>${team.total || 0}</strong> ${valueLabel}`;
    li.appendChild(span);
    list.appendChild(li);
  });
}

// Initialize page
async function init() {
  const urlParams = new URLSearchParams(window.location.search);
  const leagueId = urlParams.get('id');
  if (!leagueId || isNaN(leagueId)) {
    document.getElementById('error').textContent = 'Invalid or missing league ID.';
    return;
  }

  const league = await fetchLeagueData(leagueId);
  if (!league) return;

  document.title = `FootWire | ${sanitizeText(league.name)} Overview`;
  document.getElementById('league-name').textContent = league.name;
  document.getElementById('league-logo').src = league.logo;
  document.getElementById('league-logo').alt = `${league.name} Logo`;
  document.getElementById('league-title').textContent = league.name;
  document.getElementById('league-description').textContent = league.description;

  const tabButtons = document.querySelectorAll('.tab-btn');
  const tabContents = document.querySelectorAll('.tab-content');
  tabButtons.forEach(btn => {
    btn.addEventListener('click', async () => {
      tabButtons.forEach(b => {
        b.classList.remove('active');
        b.setAttribute('aria-selected', 'false');
      });
      tabContents.forEach(c => c.classList.remove('active'));
      btn.classList.add('active');
      btn.setAttribute('aria-selected', 'true');
      const tabContent = document.getElementById(btn.dataset.tab);
      tabContent.classList.add('active');
      if (btn.dataset.tab === 'fixtures' && !tabContent.dataset.loaded) {
        await loadFixtures(leagueId, league.seasonStart, league.seasonEnd);
        tabContent.dataset.loaded = 'true';
      }
      if (btn.dataset.tab === 'standings' && !tabContent.dataset.loaded) {
        const standings = await fetchStandings(league.seasonId);
        renderStandings(standings, 'standings-body');
        tabContent.dataset.loaded = 'true';
      }
    });
  });

  const now = new Date('2025-08-12T13:54:00+01:00'); // Updated to 01:54 PM WAT
  let allFixtures = [];
  const maxDays = 90;
  let daysChecked = 0;
  let currentDate = new Date(now);

  while (allFixtures.length < 5 && daysChecked < maxDays) {
    const dateStr = currentDate.toISOString().split('T')[0];
    const dailyFixtures = await fetchFixtures(leagueId, dateStr, dateStr);
    const upcomingDailyFixtures = dailyFixtures.filter(f => {
      const startTime = new Date(f.starting_at);
      return !isNaN(startTime.getTime()) && startTime > now;
    });
    allFixtures.push(...upcomingDailyFixtures);
    daysChecked++;
    currentDate.setDate(currentDate.getDate() + 1);
    console.log(`Checked ${dateStr} for overview, total upcoming fixtures: ${allFixtures.length}`); // Debug
  }

  renderOverviewFixtures(allFixtures, 'fixtures-preview');

  const standings = await fetchStandings(league.seasonId);
  renderStandings(standings, 'league-table-container', Math.ceil(standings.length / 2));

  async function loadFixtures(leagueId, seasonStart, seasonEnd) {
    const container = document.getElementById('fixtures-list');
    container.innerHTML = '<p>Loading fixtures...</p>';
    try {
      let upcomingPage = 1;
      let pastPage = 1;
      const perPageUpcoming = 10;
      const perPagePast = 15; // 15 past fixtures per page
      const maxDays = 90;
      let futureDaysChecked = 0;
      let pastDaysChecked = 0;
      let allFixtures = [];
      let pastFixtures = [];
      const now = new Date('2025-08-12T13:54:00+01:00'); // Updated to 01:54 PM WAT
      let currentFutureDate = new Date(now);
      let currentPastDate = new Date(now);
      currentPastDate.setDate(currentPastDate.getDate() - 1); // Start from yesterday
      const daysPerBatch = 14;
      const seasonStartDate = new Date(seasonStart || '2024-08-01');
      let hasMorePastFixtures = true; // Assume more fixtures until proven otherwise

      // Fetch future and live fixtures
      while (allFixtures.filter(f => {
        const startTime = new Date(f.starting_at);
        return !isNaN(startTime.getTime()) && startTime >= new Date(now.getTime() - 105 * 60 * 1000);
      }).length < 5 && futureDaysChecked < maxDays) {
        const startDate = new Date(currentFutureDate);
        const endDate = new Date(currentFutureDate);
        endDate.setDate(endDate.getDate() + daysPerBatch - 1);
        const startDateStr = startDate.toISOString().split('T')[0];
        const endDateStr = endDate.toISOString().split('T')[0];
        const batchFixtures = await fetchFixtures(leagueId, startDateStr, endDateStr);
        const validBatchFixtures = batchFixtures.filter(f => {
          const startTime = new Date(f.starting_at);
          return !isNaN(startTime.getTime());
        });
        allFixtures.push(...validBatchFixtures);
        futureDaysChecked += daysPerBatch;
        currentFutureDate.setDate(currentFutureDate.getDate() + daysPerBatch);
        console.log(`Checked ${startDateStr} to ${endDateStr} for upcoming fixtures, total fixtures: ${allFixtures.length}`); // Debug
      }

      // Fetch initial past fixtures (for button click)
      const pastBatchStart = new Date(currentPastDate);
      pastBatchStart.setDate(pastBatchStart.getDate() - daysPerBatch + 1);
      const pastStartDateStr = pastBatchStart.toISOString().split('T')[0];
      const pastEndDateStr = currentPastDate.toISOString().split('T')[0];
      const pastBatchFixtures = await fetchFixtures(leagueId, pastStartDateStr, pastEndDateStr);
      const validPastFixtures = pastBatchFixtures.filter(f => {
        const startTime = new Date(f.starting_at);
        const isValid = !isNaN(startTime.getTime());
        if (!isValid) console.warn('Invalid starting_at for fixture:', f);
        return isValid && startTime < now;
      });
      pastFixtures.push(...validPastFixtures);
      pastDaysChecked += daysPerBatch;
      currentPastDate.setDate(currentPastDate.getDate() - daysPerBatch);
      console.log(`Initial past fixtures fetched (${pastStartDateStr} to ${pastEndDateStr}): ${validPastFixtures.length} items, total past fixtures: ${pastFixtures.length}`); // Debug
      if (validPastFixtures.length === 0) {
        console.warn(`No past fixtures found for ${pastStartDateStr} to ${pastEndDateStr}. Checking if more can be fetched.`);
        hasMorePastFixtures = currentPastDate >= seasonStartDate;
      }

      const liveAndUpcomingFixtures = allFixtures
        .filter(f => {
          const startTime = new Date(f.starting_at);
          const isValid = !isNaN(startTime.getTime());
          if (!isValid) console.warn('Invalid starting_at for fixture:', f);
          return isValid && startTime >= new Date(now.getTime() - 105 * 60 * 1000);
        })
        .sort((a, b) => (a.starting_at_timestamp || new Date(a.starting_at).getTime()) - (b.starting_at_timestamp || new Date(b.starting_at).getTime()));
      const sortedPastFixtures = pastFixtures
        .sort((a, b) => (b.starting_at_timestamp || new Date(b.starting_at).getTime()) - (a.starting_at_timestamp || new Date(a.starting_at).getTime()));
      console.log(`Filtered live/upcoming: ${liveAndUpcomingFixtures.length}, past: ${sortedPastFixtures.length}`); // Debug

      // Render only live and upcoming fixtures initially
      renderFixtures(
        liveAndUpcomingFixtures.slice(0, perPageUpcoming), 
        'fixtures-list', 
        false, 
        false, 
        hasMorePastFixtures || pastPage * perPagePast < sortedPastFixtures.length, 
        futureDaysChecked < maxDays
      );

      let isLoading = false;

      const loadPreviousButton = document.getElementById('load-previous-matches');
      if (loadPreviousButton) {
        loadPreviousButton.addEventListener('click', async () => {
          if (isLoading) return;
          isLoading = true;
          loadPreviousButton.textContent = 'Loading...';
          loadPreviousButton.disabled = true;
          await new Promise(resolve => setTimeout(resolve, 500));
          console.log(`Rendering past fixtures: page=${pastPage}, perPagePast=${perPagePast}, current past fixtures=${sortedPastFixtures.length}, pastDaysChecked=${pastDaysChecked}, hasMorePastFixtures=${hasMorePastFixtures}, currentPastDate=${currentPastDate.toISOString().split('T')[0]}`); // Debug
          
          if (pastPage * perPagePast >= sortedPastFixtures.length && hasMorePastFixtures && currentPastDate >= seasonStartDate) {
            const pastBatchStart = new Date(currentPastDate);
            pastBatchStart.setDate(pastBatchStart.getDate() - daysPerBatch + 1);
            const pastStartDateStr = pastBatchStart.toISOString().split('T')[0];
            const pastEndDateStr = currentPastDate.toISOString().split('T')[0];
            const additionalPastFixtures = await fetchFixtures(leagueId, pastStartDateStr, pastEndDateStr);
            const newPastFixtures = additionalPastFixtures.filter(f => {
              const startTime = new Date(f.starting_at);
              const isValid = !isNaN(startTime.getTime());
              if (!isValid) console.warn('Invalid starting_at for fixture:', f);
              return isValid && startTime < now;
            });
            sortedPastFixtures.unshift(...newPastFixtures.sort((a, b) => (b.starting_at_timestamp || new Date(b.starting_at).getTime()) - (a.starting_at_timestamp || new Date(a.starting_at).getTime())));
            pastDaysChecked += daysPerBatch;
            currentPastDate.setDate(currentPastDate.getDate() - daysPerBatch);
            if (newPastFixtures.length === 0) {
              hasMorePastFixtures = false;
              console.log(`No more past fixtures fetched (${pastStartDateStr} to ${pastEndDateStr}), hasMorePastFixtures updated to ${hasMorePastFixtures}`); // Debug
            }
            console.log(`Fetched additional past fixtures (${pastStartDateStr} to ${pastEndDateStr}): ${newPastFixtures.length}, total past fixtures: ${sortedPastFixtures.length}`); // Debug
          }

          const nextPastFixtures = sortedPastFixtures.slice((pastPage - 1) * perPagePast, pastPage * perPagePast);
          renderFixtures(
            nextPastFixtures, 
            'fixtures-list', 
            true, 
            true, 
            hasMorePastFixtures || (pastPage * perPagePast < sortedPastFixtures.length), 
            futureDaysChecked < maxDays
          );
          pastPage++;

          loadPreviousButton.textContent = 'Load Previous Fixtures';
          loadPreviousButton.disabled = false;

          // Hide button only when all past fixtures are loaded after this click
          if (!hasMorePastFixtures && (pastPage - 1) * perPagePast >= sortedPastFixtures.length) {
            loadPreviousButton.style.display = 'none';
            console.log('Hiding Load Previous Fixtures button: all past fixtures exhausted, page=', pastPage - 1, 'total=', sortedPastFixtures.length); // Debug
          }
          isLoading = false;
        });
      } else {
        console.error('Load Previous Fixtures button not found after rendering'); // Debug
      }

      window.addEventListener('scroll', async () => {
        if (isLoading) return;
        const { scrollTop, scrollHeight, clientHeight } = document.documentElement;
        if (scrollTop + clientHeight >= scrollHeight - 50 && futureDaysChecked < maxDays) {
          isLoading = true;
          container.insertAdjacentHTML('beforeend', '<p class="loading">Loading more fixtures...</p>');
          await new Promise(resolve => setTimeout(resolve, 500));
          const startDate = new Date(currentFutureDate);
          const endDate = new Date(currentFutureDate);
          endDate.setDate(endDate.getDate() + daysPerBatch - 1);
          const startDateStr = startDate.toISOString().split('T')[0];
          const endDateStr = endDate.toISOString().split('T')[0];
          if (startDateStr > seasonEnd) {
            container.querySelector('.loading')?.remove();
            isLoading = false;
            return;
          }
          const additionalFixtures = await fetchFixtures(leagueId, startDateStr, endDateStr);
          const sortedAdditionalFixtures = additionalFixtures
            .filter(f => {
              const startTime = new Date(f.starting_at);
              const isValid = !isNaN(startTime.getTime());
              if (!isValid) console.warn('Invalid starting_at for fixture:', f);
              return isValid && startTime >= now;
            })
            .sort((a, b) => (a.starting_at_timestamp || new Date(a.starting_at).getTime()) - (b.starting_at_timestamp || new Date(b.starting_at).getTime()));
          renderFixtures(
            sortedAdditionalFixtures, 
            'fixtures-list', 
            true, 
            false, 
            hasMorePastFixtures || (pastPage * perPagePast < sortedPastFixtures.length), 
            futureDaysChecked + daysPerBatch < maxDays
          );
          futureDaysChecked += daysPerBatch;
          currentFutureDate.setDate(currentFutureDate.getDate() + daysPerBatch);
          console.log(`Checked ${startDateStr} to ${endDateStr} for infinite scroll, additional fixtures: ${sortedAdditionalFixtures.length}`); // Debug
          container.querySelector('.loading')?.remove();
          isLoading = false;
        }
      });
    } catch (err) {
      console.error('Failed to load fixtures:', err);
      container.innerHTML = '<p class="error">No fixtures available for this date range. Try again later or check server logs.</p>';
    }
  }

  const seasonId = league.seasonId;
  const [
    topScorers,
    topAssisters,
    redCards,
    yellowCards,
    teamGoals,
    teamCleanSheets
  ] = await Promise.all([
    fetchStat('/topscorers', seasonId),
    fetchStat('/topassists', seasonId),
    fetchStat('/redcards', seasonId),
    fetchStat('/yellowcards', seasonId),
    fetchStat('/teamstats/goals', seasonId),
    fetchStat('/teamstats/cleansheets', seasonId)
  ]);
  renderPlayerList('#top-goals', topScorers, 'goals');
  renderPlayerList('#top-assists', topAssisters, 'assists');
  renderPlayerList('#top-reds', redCards, 'reds');
  renderPlayerList('#top-yellows', yellowCards, 'yellows');
  renderTeamList('#team-goals', teamGoals, 'goals');
  renderTeamList('#team-cleansheets', teamCleanSheets, 'clean sheets');

  const overviewTab = document.querySelector('.tab-btn[data-tab="overview"]');
  if (overviewTab) overviewTab.click();
}

init();

  </script>
</body>
</html>